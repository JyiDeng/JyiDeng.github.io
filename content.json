{"meta":{"title":"JyiDeng的主页","subtitle":"来自2022FDU软件工程","description":"来自2022FDU软件工程。\\n喜欢美食！","author":"JyiDeng","url":"http://JyiDeng.github.io","root":"/"},"pages":[{"title":"categories","date":"2025-02-21T13:43:53.000Z","updated":"2025-02-21T13:43:54.000Z","comments":true,"path":"categories/index.html","permalink":"http://jyideng.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2025-02-21T13:44:00.000Z","updated":"2025-02-21T13:44:02.000Z","comments":true,"path":"tags/index.html","permalink":"http://jyideng.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"本地部署ollama+deepseek-r1排错攻略(ollama版本过低/自定义安装路径/不显示思路/500 INTERNAL_ERROR/其他常用链接传送门)","slug":"本地部署ollama-deepseek-r1排错攻略-ollama版本过低-自定义安装路径-不显示思路-500-INTERNAL-ERROR-其他常用链接传送门","date":"2025-02-06T10:06:01.000Z","updated":"2025-02-21T12:32:56.000Z","comments":true,"path":"2025/02/06/本地部署ollama-deepseek-r1排错攻略-ollama版本过低-自定义安装路径-不显示思路-500-INTERNAL-ERROR-其他常用链接传送门/","permalink":"http://jyideng.github.io/2025/02/06/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2ollama-deepseek-r1%E6%8E%92%E9%94%99%E6%94%BB%E7%95%A5-ollama%E7%89%88%E6%9C%AC%E8%BF%87%E4%BD%8E-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84-%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%80%9D%E8%B7%AF-500-INTERNAL-ERROR-%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E9%93%BE%E6%8E%A5%E4%BC%A0%E9%80%81%E9%97%A8/","excerpt":"​1. ollama版本过低，deepseek回复为空，qwen无法chat2. ollama改变&#x2F;自定义安装路径3. Error: pull model manifest: 500: {“errors”:[{“code”:”INTERNAL_ERROR”,”message”:”internal error”}]}4. 在cmd使用ollama run，无法显示&lt;think&gt;的思路5. 其他各类deepseek信息传送门","text":"​1. ollama版本过低，deepseek回复为空，qwen无法chat2. ollama改变&#x2F;自定义安装路径3. Error: pull model manifest: 500: {“errors”:[{“code”:”INTERNAL_ERROR”,”message”:”internal error”}]}4. 在cmd使用ollama run，无法显示&lt;think&gt;的思路5. 其他各类deepseek信息传送门 本人环境：Windows 11，不使用docker，直接安装ollama；16GB RAM，无GPU。 1. ollama版本过低，deepseek回复为空，qwen无法chat 正确安装ollama、正确拉取deepseek-r1:1.5b后，能够用ollama list找到有这个模型，也有chat提示语（&gt;&gt;&gt;Send a message (/? for help) ) ，但是和模型chat的过程中，deepseek的回复为空；为了验证问题所在，正确拉取qwen2:0.5b，但是无法开始chat，报错：Error: llama runner process no longer running: 3221226505 解决方案：用 ollama --version 查询版本是0.1.x，结合以上两个问题来看，ollama版本太低了。灵感来自：使用ollama运行llama3.1遇到问题+手工升级ollama 先卸载当前ollama，再回到官网下载更高版本的ollama（据2025年2月6日观察，0.5.x 好使）。具体如何安装，可以看以下第二点里的链接： 2. ollama改变&#x2F;自定义安装路径 ollama的setup.exe运行的时候，是不能手动选择安装位置、model存放位置的。 如果你已经安装完ollama，并且想改路径，方法一（不推荐）：安装完以后，把整个ollama可执行文件所在的文件夹、整个models文件夹移动到想要的位置，并且修改相应的2个环境变量。不推荐，是因为可能导致上面第一点的问题。具体操作方法，参考文章：在Windows中将Ollama安装到其他盘（例如D盘）的步骤如下_ollama安装到d盘-CSDN博客 如果你还没安装ollama，方法二更好：直接在安装时修改路径，OllamaSetup.exe /DIR=你想要安装的位置，并且修改相应的2个环境变量。具体操作方法，参考文章：自定义Ollama安装路径 - 不愿透露姓名的菜鸟 - 博客园 ；或者 OLLAMA win11安装完整指南（安装时指定路径） 备注：models默认目录为 C:\\Users%username%.ollama\\models，这个.ollama文件夹里的server.log可以用来排除错误，其中的内容和 ollama serve的一致，想要运行后者的命令，需要当前没有ollama正在运行，具体操作可以参考：Windows安装与配置Ollama-CSDN博客 3. Error: pull model manifest: 500: {“errors”:[{“code”:”INTERNAL_ERROR”,”message”:”internal error”}]} 根据 GitHub: pull model manifest: 500 #8873 ：北京时间2025年2月6日16:20左右开始，拉取不了新模型 解决方案：等待ollama修复。结果：17:30左右，可以正常pull了。 （觉得速度很慢？本人使用魔法后，对于提速依然无效，只能硬等。。。） 4. 在cmd使用ollama run，无法显示&lt;think&gt;的思路 &lt;think&gt;&lt;&#x2F;think&gt;中，内容为空；问题回答太过简单，甚至有些不带脑子。 可能原因： 在cmd的默认路径（C:\\Users\\你的用户名）进行ollama run 你的模型名字，确实会导致它的回答不带脑子（我也很好奇为什么）。 解决方案1：换一个路径，譬如在cmd 输入 cd Downloads 即可。 解决方案2：写程序调用。（js程序见下） 解决方案3：使用Chatbox等工具调用。参考：高效快速教你deepseek如何进行本地部署并且可视化对话 问题过于简单，譬如聊天中的第一句“你好”，确实没有思考过程。 可能是版本过低，跳转第一点问题与解决。 可参考的最简易版 javascript 程序： fetch(&quot;http://localhost:11434/api/generate&quot;, &#123; method: &quot;POST&quot;, headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot; &#125;, body: JSON.stringify(&#123; model: &quot;deepseek-r1:1.5b&quot;, prompt: &quot;如果一只橘子坚称它是一只猫，人工智能该怎么办？&quot;, stream: false &#125;)&#125;) .then(response =&gt; response.json()) .then(data =&gt; console.log(data)); 5. 其他各类deepseek信息传送门ollama官网下载链接（访问网页不需要魔法，但下载需要）： Download Ollama ，或者GitHub下载链接：Releases · ollama&#x2F;ollama 各个deepseek模型对应的电脑性能：DeepSeek模型各版本硬件要求指南 ，以及（这篇不确定是不是AI撰写的）：DeepSeek编码器可以在预算友好的设置上运行，还是需要高端硬件 ​ollama 相关命令：菜鸟教程-Ollama 相关命令 Chatbox官网下载链接（访问网页不需要魔法，但下载需要）：Chatbox AI，或者GitHub下载链接：Releases · Bin-Huang&#x2F;chatbox","categories":[],"tags":[{"name":"ollama","slug":"ollama","permalink":"http://jyideng.github.io/tags/ollama/"},{"name":"Deepseek","slug":"Deepseek","permalink":"http://jyideng.github.io/tags/Deepseek/"},{"name":"nlp","slug":"nlp","permalink":"http://jyideng.github.io/tags/nlp/"}]},{"title":"make使用clang++报cstdlib.h等头文件找不到(ubuntu22.04)","slug":"make使用clang-报cstdlib-h等头文件找不到-ubuntu22-04","date":"2024-11-13T03:09:08.000Z","updated":"2025-02-21T12:27:24.000Z","comments":true,"path":"2024/11/13/make使用clang-报cstdlib-h等头文件找不到-ubuntu22-04/","permalink":"http://jyideng.github.io/2024/11/13/make%E4%BD%BF%E7%94%A8clang-%E6%8A%A5cstdlib-h%E7%AD%89%E5%A4%B4%E6%96%87%E4%BB%B6%E6%89%BE%E4%B8%8D%E5%88%B0-ubuntu22-04/","excerpt":"","text":"本人环境：Ubuntu22.04。出于项目要求，必须用clang++，不能用g++。 更新clang++版本无用，更新llvm版本无用，在makefile添加 -I 来增加include路径也没用。 最后gpt给的解决方法解决了问题： sudo apt install g++-12 libstdc++-12-dev 而且，本人通过g++ –version发现我的版本是11（具体来说：gcc version 11.4.0 (Ubuntu 11.4.0-1ubuntu1~22.04) ），但是偏偏就是安装上方的12才能解决问题，把12换成11不行。 此外，在做上方安装之前，我做过一个路径添加（不过应该是临时的吧），或许可以一试，但不能直接解决问题： export CPLUS_INCLUDE_PATH=/usr/include/c++/11","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://jyideng.github.io/tags/ubuntu/"},{"name":"clang++","slug":"clang","permalink":"http://jyideng.github.io/tags/clang/"}]},{"title":"TodoList：记初次Vuex探索（本地+Codepen）（使用component）(版本：vue2, vuex3)","slug":"TodoList：记初次Vuex探索（本地-Codepen）（使用component）-版本：vue2-vuex3","date":"2024-07-17T10:07:20.000Z","updated":"2025-02-21T14:54:06.000Z","comments":true,"path":"2024/07/17/TodoList：记初次Vuex探索（本地-Codepen）（使用component）-版本：vue2-vuex3/","permalink":"http://jyideng.github.io/2024/07/17/TodoList%EF%BC%9A%E8%AE%B0%E5%88%9D%E6%AC%A1Vuex%E6%8E%A2%E7%B4%A2%EF%BC%88%E6%9C%AC%E5%9C%B0-Codepen%EF%BC%89%EF%BC%88%E4%BD%BF%E7%94%A8component%EF%BC%89-%E7%89%88%E6%9C%AC%EF%BC%9Avue2-vuex3/","excerpt":"​一、写在前面+效果图二、Vuex2.1 Codepen：html+js+css2.1.1 一个可能更加通顺的思路2.2 本地：App.vue，components&#x2F;component1.vue，store&#x2F;index.js","text":"​一、写在前面+效果图二、Vuex2.1 Codepen：html+js+css2.1.1 一个可能更加通顺的思路2.2 本地：App.vue，components&#x2F;component1.vue，store&#x2F;index.js 写在前面+效果图本次是探索性质，肯定有一定差错和不足，我会继续学习。 不做详细的vue和vuex语法、功能介绍，因为官方文档讲得比我清楚，我主要是提供撰写的顺序思路，以及完整的代码。 目录在上面，自取所需。 效果图： VuexCodepen：html+js+css如何在这个界面使用vuex？只需要在html里写上： &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vuex@3.6.2/dist/vuex.js&quot;&gt;&lt;/script&gt; codepen这里的意思就是不分文件层级，所有js都在一个js里，html、css也是，确实很简洁。 一个可能更加通顺的思路对于js部分，首先把框架写出来，三个部分：new Vue、vue的组件、Vuex部分： Const store = new Vuex.Store(&#123; mutations:&#123; &#125;, getters:&#123; &#125;, actions:&#123; &#125;,&#125;);vue.component(&#x27;c1&#x27;,&#123; template:` `, data()&#123; &#125;, computed()&#123; &#125;, methods:&#123; &#125;, &#125;);vue.component(&#x27;c2&#x27;,&#123;&#125;);New Vue(&#123; el: &#x27;#app&#x27;, store, created()&#123; this.$store.commit(&quot;loadTodos&quot;); &#125;&#125;); 然后，根据界面里有什么，构想各个component应该长什么样，譬如我认为，我需要一个header，还需要一个content。 html：对的，用组件就这么简单明了。 &lt;div id=&quot;app&quot;&gt; &lt;header-component&gt;&lt;/header-component&gt; &lt;content-component&gt;&lt;/content-component&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vuex@3.6.2/dist/vuex.js&quot;&gt;&lt;/script&gt; 根据html设计思路，在Vue.component里填写template内容：譬如div、button，以及一些要用的变量，一开始只写个框，譬如&lt;button&gt;增加&lt;/button&gt;，&#123;&#123;total&#125;&#125;，先不考虑这个变量存不存在，以便于排除冗杂的信息； 接着，根据文字说明，具体地填写功能，譬如我要实现增加，我就要点这个按钮调用函数，所以我扩充为&lt;button @click=&quot;addTodo&quot;&gt;增加&lt;/button&gt;： Vue.component(&quot;header-component&quot;, &#123; template: ` &lt;div class=&quot;header&quot;&gt; &lt;div class=&quot;filter&quot;&gt; &lt;button @click=&quot;myFilter(&#x27;all&#x27;)&quot;&gt;全部&lt;/button&gt; &lt;button @click=&quot;myFilter(&#x27;finished&#x27;)&quot;&gt;已完成&lt;/button&gt; &lt;button @click=&quot;myFilter(&#x27;not-finished&#x27;)&quot;&gt;未完成&lt;/button&gt; &lt;span&gt;总共&#123;&#123; total &#125;&#125;条，已完成&#123;&#123; completed &#125;&#125;条，剩余&#123;&#123; remaining &#125;&#125;条&lt;/span&gt; &lt;button @click=&quot;clearCompleted&quot;&gt;清除已完成&lt;/button&gt; &lt;button @click=&quot;checkAll&quot;&gt;全部完成&lt;/button&gt; &lt;button class=&quot;headerAdd&quot; @click=&quot;addTodo&quot;&gt;增加新的TODO&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; `,// 以下省略&#125; 既然写了一些想实现的方法，譬如addTodo，那么接下来就在各个component的methods里写上要让vuex调用数据驱动的方法的大概样子（有点像先写个抽象类，之后再完善），格式都是this.$store.commit(‘vuex里的方法名’,要传的变量); 变量也是如此，在computed里写。vuex里已有的变量用this.$store.state，要计算的变量用this.$store.getters（这个目前还不知道要不要计算，所以先写一个试试） 那么现在vue的部分完成了，要写vuex了。根据之前的这些commit、state、getters的内容，填充Vuex，先写mutation，再写getters，过程中会发现需要变量，就往state里加。大概长图片那样 mutations和getters：每个函数的第一个变量都是state，修改state{}里的数据必须用这个前缀；第二个开始的参数是传入的，根据之前写的来 具体功能就在这里实现，这就是数据驱动的精妙之处，具体的操作都让vuex执行，不用vue的component之前传来传去的麻烦 getters需要return，之前的computed也要写return，别忘了就是。 最后，进行功能检查：getters和computed用对了吗，dispatch和commit用对了吗，其他各种检查。那么vuex的功能差不多也完成了。 codepen这种情况下的总体代码： html里： &lt;div id=&quot;app&quot;&gt; &lt;header-component&gt;&lt;/header-component&gt; &lt;content-component&gt;&lt;/content-component&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vuex@3.6.2/dist/vuex.js&quot;&gt;&lt;/script&gt; js里： Vue.component(&quot;header-component&quot;, &#123; template: ` &lt;div class=&quot;header&quot;&gt; &lt;div class=&quot;filter&quot;&gt; &lt;button @click=&quot;myFilter(&#x27;all&#x27;)&quot;&gt;全部&lt;/button&gt; &lt;button @click=&quot;myFilter(&#x27;finished&#x27;)&quot;&gt;已完成&lt;/button&gt; &lt;button @click=&quot;myFilter(&#x27;not-finished&#x27;)&quot;&gt;未完成&lt;/button&gt; &lt;span&gt;总共&#123;&#123; total &#125;&#125;条，已完成&#123;&#123; completed &#125;&#125;条，剩余&#123;&#123; remaining &#125;&#125;条&lt;/span&gt; &lt;button @click=&quot;clearCompleted&quot;&gt;清除已完成&lt;/button&gt; &lt;button @click=&quot;checkAll&quot;&gt;全部完成&lt;/button&gt; &lt;button class=&quot;headerAdd&quot; @click=&quot;addTodo&quot;&gt;增加新的TODO&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; `, computed: &#123; total() &#123; return this.$store.state.todoList.length; &#125;, completed() &#123; return this.$store.getters.completed; &#125;, remaining() &#123; return this.$store.getters.remaining; &#125; &#125;, methods: &#123; myFilter(status) &#123; this.$store.commit(&quot;setFilterStatus&quot;, status); &#125;, clearCompleted() &#123; this.$store.commit(&quot;clearCompleted&quot;); &#125;, checkAll() &#123; this.$store.commit(&quot;checkAll&quot;); &#125;, addTodo() &#123; this.$store.commit(&quot;addTodo&quot;); &#125; &#125;&#125;);Vue.component(&quot;content-component&quot;, &#123; template: ` &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;todo-item&quot; v-for=&quot;(item, index) in filteredTodoList&quot; :key=&quot;item.id&quot; transition=&quot;zj&quot;&gt; &lt;input class=&quot;checkbox&quot; type=&quot;checkbox&quot; @click=&quot;check(index, item.id)&quot; v-model=&quot;item.isChecked&quot;&gt; &lt;input class=&quot;item-input&quot; v-model=&quot;item.text&quot; type=&quot;text&quot; :disabled=&quot;item.isChecked&quot; @blur=&quot;handleBlur()&quot;&gt; &lt;input type=&quot;datetime-local&quot; v-model=&quot;item.time&quot; @blur=&quot;handleBlur&quot;&gt; &lt;button @click=&quot;removeTodo(index, item.id)&quot;&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; `, computed: &#123; filteredTodoList() &#123; return this.$store.getters.filteredTodoList; &#125; &#125;, methods: &#123; check(index, id) &#123; this.$store.commit(&quot;check&quot;, &#123; index, id &#125;); &#125;, removeTodo(index, id) &#123; this.$store.commit(&quot;removeTodo&quot;, &#123; index, id &#125;); &#125;, handleBlur() &#123; this.$store.commit(&quot;saveTodos&quot;); &#125; &#125;&#125;);const store = new Vuex.Store(&#123; state: &#123; todoList: [], filterStatus: &quot;all&quot; &#125;, getters: &#123; filteredTodoList(state) &#123; if (state.filterStatus === &quot;finished&quot;) &#123; return state.todoList.filter((item) =&gt; item.isChecked); &#125; else if (state.filterStatus === &quot;not-finished&quot;) &#123; return state.todoList.filter((item) =&gt; !item.isChecked); &#125; else &#123; return state.todoList; &#125; &#125;, total(state) &#123; return state.todoList.length; &#125;, completed(state) &#123; return state.todoList.filter((item) =&gt; item.isChecked).length; &#125;, remaining(state) &#123; return state.todoList.filter((item) =&gt; !item.isChecked).length; &#125; &#125;, mutations: &#123; setFilterStatus(state, status) &#123; state.filterStatus = status; &#125;, addTodo(state) &#123; state.todoList.unshift(&#123; id: Number(Math.random().toString().substr(2, 10) + Date.now()).toString( 10 ), isChecked: false, text: &quot;&quot;, time: new Date().toISOString().slice(0, 16) &#125;); localStorage.setItem(&quot;todoList1&quot;, JSON.stringify(state.todoList)); &#125;, removeTodo(state, &#123; index, id &#125;) &#123; if (state.todoList[index].id === id) &#123; state.todoList.splice(index, 1); localStorage.setItem(&quot;todoList1&quot;, JSON.stringify(state.todoList)); &#125; &#125;, check(state, &#123; index, id &#125;) &#123; if (state.todoList[index].id === id) &#123; state.todoList[index].isChecked = !state.todoList[index].isChecked; localStorage.setItem(&quot;todoList1&quot;, JSON.stringify(state.todoList)); &#125; &#125;, checkAll(state) &#123; state.todoList.forEach((item) =&gt; &#123; item.isChecked = true; &#125;); localStorage.setItem(&quot;todoList1&quot;, JSON.stringify(state.todoList)); &#125;, clearCompleted(state) &#123; state.todoList = state.todoList.filter((item) =&gt; !item.isChecked); localStorage.setItem(&quot;todoList1&quot;, JSON.stringify(state.todoList)); &#125;, saveTodos(state) &#123; localStorage.setItem(&quot;todoList1&quot;, JSON.stringify(state.todoList)); &#125;, loadTodos(state) &#123; const tmp = localStorage.getItem(&quot;todoList1&quot;); if (tmp) &#123; state.todoList = JSON.parse(tmp); &#125; else &#123; state.todoList = [ &#123; id: Number(Math.random().toString().substr(2, 10) + Date.now()).toString( 10 ), text: &quot;请点击上方的添加按钮添加事件&quot;, isChecked: false, time: new Date().toISOString().slice(0, 16) &#125; ]; &#125; &#125; &#125;&#125;);new Vue(&#123; el: &quot;#app&quot;, store, created() &#123; this.$store.commit(&quot;loadTodos&quot;); &#125;&#125;); css部分请自由发挥。 本地：App.vue，components&#x2F;component1.vue，store&#x2F;index.js，main.js内容还是基本一样的，本地的问题主要是看东西放在哪个文件夹。 首先你得装了vue；然后在一个文件夹启动环境；而且要在同一个文件夹装vuex。 这样的话，你将会看到的结构：（TEST_VUE是根目录；store文件夹本来没有，自己建一个。） App.vue同级还需要一个main.js: 请看各个文件 App.vue几乎完全一样: &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;header-component&gt;&lt;/header-component&gt; &lt;content-component&gt;&lt;/content-component&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt; store&#x2F;index.js：放的是vuex的东西，记得import和Vue.use(vuex) 注意export default new Vuex.Store代替了之前的new store &#x3D; Vuex.Store，不改的话会报错：We‘re sorry but doesn’t work properly without JavaScript enabled. Please enable it to continue import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; todoList: [], filterStatus: &quot;all&quot; &#125;, getters: &#123; filteredTodoList(state) &#123; if (state.filterStatus === &quot;finished&quot;) &#123; return state.todoList.filter((item) =&gt; item.isChecked); &#125; else if (state.filterStatus === &quot;not-finished&quot;) &#123; return state.todoList.filter((item) =&gt; !item.isChecked); &#125; else &#123; return state.todoList; &#125; &#125;, total(state) &#123; return state.todoList.length; &#125;, completed(state) &#123; return state.todoList.filter((item) =&gt; item.isChecked).length; &#125;, remaining(state) &#123; return state.todoList.filter((item) =&gt; !item.isChecked).length; &#125; &#125;, mutations: &#123; setFilterStatus(state, status) &#123; state.filterStatus = status; &#125;, addTodo(state) &#123; state.todoList.unshift(&#123; id: Number(Math.random().toString().substr(2, 10) + Date.now()).toString( 10 ), isChecked: false, text: &quot;&quot;, time: new Date().toISOString().slice(0, 16) &#125;); localStorage.setItem(&quot;todoList1&quot;, JSON.stringify(state.todoList)); &#125;, removeTodo(state, &#123; index, id &#125;) &#123; if (state.todoList[index].id === id) &#123; state.todoList.splice(index, 1); localStorage.setItem(&quot;todoList1&quot;, JSON.stringify(state.todoList)); &#125; &#125;, check(state, &#123; index, id &#125;) &#123; if (state.todoList[index].id === id) &#123; state.todoList[index].isChecked = !state.todoList[index].isChecked; localStorage.setItem(&quot;todoList1&quot;, JSON.stringify(state.todoList)); &#125; &#125;, checkAll(state) &#123; state.todoList.forEach((item) =&gt; &#123; item.isChecked = true; &#125;); localStorage.setItem(&quot;todoList1&quot;, JSON.stringify(state.todoList)); &#125;, clearCompleted(state) &#123; state.todoList = state.todoList.filter((item) =&gt; !item.isChecked); localStorage.setItem(&quot;todoList1&quot;, JSON.stringify(state.todoList)); &#125;, saveTodos(state) &#123; localStorage.setItem(&quot;todoList1&quot;, JSON.stringify(state.todoList)); &#125;, loadTodos(state) &#123; const tmp = localStorage.getItem(&quot;todoList1&quot;); if (tmp) &#123; state.todoList = JSON.parse(tmp); &#125; else &#123; state.todoList = [ &#123; id: Number(Math.random().toString().substr(2, 10) + Date.now()).toString( 10 ), text: &quot;请点击上方的添加按钮添加事件&quot;, isChecked: false, time: new Date().toISOString().slice(0, 16) &#125; ]; &#125; &#125; &#125;&#125;); main.js：注意下面的东西路径正确，注意header-component是最终使用在html的名字，不能写错；注意这里用了mount，和之前不一样了 import Vue from &#x27;vue&#x27;;import store from &#x27;./store/index.js&#x27;;import app from &#x27;./App.vue&#x27;;import HeaderComponent from &#x27;./components/header.vue&#x27;;import ContentComponent from &#x27;./components/content.vue&#x27;;Vue.component(&#x27;header-component&#x27;, HeaderComponent);Vue.component(&#x27;content-component&#x27;, ContentComponent);new Vue(&#123; store, render: (h) =&gt; h(app)&#125;).$mount(&#x27;#app&#x27;); components&#x2F;content.vue：注意export default的变化。header那个也类似地调整一下。 &lt;template&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;todo-item&quot; v-for=&quot;(item, index) in filteredTodoList&quot; :key=&quot;item.id&quot; transition=&quot;zj&quot;&gt; &lt;input class=&quot;todo-item__checkbox&quot; type=&quot;checkbox&quot; @click=&quot;check(index, item.id)&quot; v-model=&quot;item.isChecked&quot;&gt; &lt;input class=&quot;todo-item__item-input&quot; v-model=&quot;item.text&quot; type=&quot;text&quot; :disabled=&quot;item.isChecked&quot; @blur=&quot;handleBlur()&quot;&gt; &lt;input type=&quot;todo-item__datetime-local&quot; v-model=&quot;item.time&quot; @blur=&quot;handleBlur&quot;&gt; &lt;button @click=&quot;removeTodo(index, item.id)&quot;&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; computed: &#123; filteredTodoList() &#123; return this.$store.getters.filteredTodoList; &#125; &#125;, methods: &#123; check(index, id) &#123; this.$store.commit(&quot;check&quot;, &#123; index, id &#125;); &#125;, removeTodo(index, id) &#123; this.$store.commit(&quot;removeTodo&quot;, &#123; index, id &#125;); &#125;, handleBlur() &#123; this.$store.commit(&quot;saveTodos&quot;); &#125; &#125;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 差不多就完成了。 其他的具体配置我也不懂了，主要还是跟着其他人的教程进行安装，有问题就找攻略修。希望大家都写得顺利！ ​","categories":[],"tags":[{"name":"Vuex","slug":"Vuex","permalink":"http://jyideng.github.io/tags/Vuex/"}]},{"title":"初识hikari框架+Mockito软件测试笔记","slug":"初识hikari框架-Mockito软件测试笔记","date":"2024-04-17T09:52:41.000Z","updated":"2025-02-21T14:54:16.000Z","comments":true,"path":"2024/04/17/初识hikari框架-Mockito软件测试笔记/","permalink":"http://jyideng.github.io/2024/04/17/%E5%88%9D%E8%AF%86hikari%E6%A1%86%E6%9E%B6-Mockito%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0/","excerpt":"一、hikari框架的各层次内容解释（导图）二、会用到的测试：Mockito 的 MockMvc2.1. 正向思考简单的Mockito的测试怎么写2.2. 一个完整测试段落的例子2.3. when...thenReturn或者given...willReturn或者doNothing函数2.4. perform和andExpect函数：用来模拟http连接的2.5. verify函数：验证方法是否被调用过、调用过几次2.6. json相关操作:$[i]的意思是第i个参数、$是数组2.7. perform....andExpect里的is3xxRedirection()","text":"一、hikari框架的各层次内容解释（导图）二、会用到的测试：Mockito 的 MockMvc2.1. 正向思考简单的Mockito的测试怎么写2.2. 一个完整测试段落的例子2.3. when...thenReturn或者given...willReturn或者doNothing函数2.4. perform和andExpect函数：用来模拟http连接的2.5. verify函数：验证方法是否被调用过、调用过几次2.6. json相关操作:$[i]的意思是第i个参数、$是数组2.7. perform....andExpect里的is3xxRedirection() 首次发表在：https://blog.csdn.net/weixin_50132289/article/details/137880658​ 一、hikari框架的各层次内容解释（导图）以前第一次见到类似的框架还是ruoyi框架。彼时的我还完全不明白这种文件结构，看到就怕。现在做了个思维导图小梳理，图中以我本次课程作业中的entity-Message为例，衍生出相关的controller、dao、service。 二、会用到的测试：Mockito 的 MockMvc对于其中的各个常用方法进行了梳理。仅作示例作用，并没有深入解释其原理。对我帮助很大的Mockito应用指南：https://hezhiqiang8909.gitbook.io/java/docs/javalib/mockito 1. 正向思考简单的Mockito的测试怎么写此处作为总结，本文后面有一些我遇到的例子。再次说明，仅作示例作用，并未深入解释原理。 @ExtendWith、@WebMvcTest、@MockBean配置好 @BeforeEach进行setup，初始化全局变量 @Test每一个controller类里的方法，初始化局部变量，譬如一些列表、一些到Page的映射 对模拟出来的变量配置返回值：given…willReturn 或 when…thenReturn（或 doNothing）。 · 具体语法：when(xxxService的函数(函数调用的参数…)).thenReturn(模拟出来的东西的返回值) 使用Mockito的 perform…andExpect 进行HTTP连接，测试连接是否200、相应属性是否正确、返回值如何；如有需要，测试能否redirect到下一个指定的网页。 · 具体语法：mockMvc.perform(get(网址).sessionAttrs或params).andExpect(status().isOk()).andExpect(view().name(xxx)).andExpect(model().attribute(expected,actual)) 使用Mockito的 verify 方法，对于属性和状态进行测试对于前述配置过的函数被调用的次数进行测试。 · 具体语法：verify(xxxService).xxxService刚才调用的函数(函数的参数) 如果需要，如果被测试类里有 成功vs失败、不重复vs重复、登录与否、更改密码&#x2F;图片 等等的分类讨论，那么可以考虑写成多个测试类 2. 一个完整测试段落的例子@Testvoid modifyMessage() throws Exception&#123; // 局部变量初始化 int messageID = 1; String content = &quot;Updated message content&quot;; Message message = new Message(); message.setContent(content); message.setTime(LocalDateTime.now()); message.setState(1); // when...thenReturn when(messageService.findById(messageID)).thenReturn(message); // perform...post mockMvc.perform(post(&quot;/modifyMessage.do&quot;) .param(&quot;messageID&quot;, String.valueOf(messageID)) .param(&quot;content&quot;, content)) .andExpect(status().isOk()) .andExpect(content().string(&quot;true&quot;)); // return value // verify verify(messageService, times(1)).findById(messageID); verify(messageService, times(1)).update(message); // 这里是Junit的测试方法，assertEquals(预期值，实际值)判断两者是否相等 // 体现Junit可以和Mockito结合使用 assertEquals(content, message.getContent()); assertEquals(1, message.getState());&#125; 3. when...thenReturn或者given...willReturn或者doNothing函数：都用于配置、指定模拟对象的行为，模拟对象应该返回的东西。// when和given分别来一个例子 when(messageService.findWaitState(message_pageable)).thenReturn(messagePage); given(venueService.findAll(any())).willReturn(venues);// 可以做一点小改变 // 自定义 getUniqueId() 的返回值 when(test.getUniqueId()).thenReturn(43); // 在测试中使用mock对象 assertEquals(test.getUniqueId(), 43); // doNothing：当 messageService.confirmMessage 方法被调用时，不做任何操作。 doNothing().when(messageService).confirmMessage(id_user_success); 用于配置模拟对象的行为，是为了模拟方法的返回值，使得在测试中可以预先定义方法的执行结果，这种方式允许测试特定方法在给定参数下的行为，以便测试代码的其他部分能够按预期工作。 when： 当调用 findWaitState 方法并传入指定的 message_pageable 对象时（findWaitState），模拟对象应该返回 messagePage 对象。 given：当调用 venueService.findAll(pageable) 方法时（findAll(any())），模拟对象应该返回 pagedResponse 对象。 3.1 关于其中的findAll本次课程作业中有一个将结果封装成Page&lt;EntityName&gt;的功能。因此在测试的时候，findAll的作用是根据传入的 pageable 参数，从数据库中查询符合条件的场馆数据，并将结果封装成一个 Page&lt;EntityName&gt; 对象返回，举例：返回Page&lt;Venue&gt; Page&lt;Venue&gt; findAll(Pageable pageable);when(venueService.findAll(pageable)).thenReturn(pageOfVenues);given(venueService.findAll(any())).willReturn(venues); 4. perform和andExpect函数：用来模拟http连接的mockMvc.perform(get(&quot;/message_manage&quot;)) .andExpect(status().isOk()) .andExpect(view().name(&quot;admin/message_manage&quot;)) .andExpect(model().attribute(&quot;total&quot;, messagePage.getTotalPages())); 使用 mockMvc 执行模拟的 HTTP GET 请求到 &#x2F;message_manage 路径。 预期响应状态status码为 200 (OK)，视图view也就是在原有的类里返回的值名称为 admin&#x2F;message_manage。 验证模型中的 total 属性是否等于 messagePage 的总页数，写这句是因为在原有的类里有对model的attribute进行赋值等操作。 5. verify函数：验证方法是否被调用过、调用过几次// 举两个例子 verify(messageService, times(/*wanted number of invocations*/1)).findWaitState(message_pageable); verify(venueService).findAll(pageable); // 原型可做了解 @CheckReturnValue public static &lt;T&gt; T verify(T mock, VerificationMode mode) &#123; return MOCKITO_CORE.verify(mock, mode); &#125; messageService 是要验证的模拟对象。 times(1) 指定了方法 findWaitState 应该被调用的次数，这里是期望被调用一次。 后续的findWaitState(message_pageable) 是实际要验证的方法调用，message_pageable 是该方法的参数。 这行代码的作用是确保 messageService.findWaitState(message_pageable) 方法被调用了一次。如果调用次数不符合期望，将会抛出验证失败的异常，从而可以确保方法在测试中按预期执行。 @CheckReturnValue 注解是用来提示调用者检查方法的返回值，确保返回值不被忽略，它提醒调用该方法后应该考虑处理方法的返回值，例如赋值给变量、进行检查或者使用返回值执行其他操作，以免造成程序逻辑错误或资源泄漏等问题。 6. json相关操作:$[i]的意思是第i个参数、$是数组mockMvc.perform(get(&quot;/venueList.do&quot;) .param(&quot;page&quot;, String.valueOf(page))) .andExpect(status().isOk()) .andExpect(content().contentType(&quot;application/json&quot;)) // 表示期望返回的响应内容类型为 application/json，即 JSON 格式 .andExpect(jsonPath(&quot;$&quot;, hasSize(1))) // 表示期望返回的 JSON 数组 $ 的长度为 1，即结果包含一个元素 .andExpect(jsonPath(&quot;$[0].venueID&quot;, is(1))) // 表示期望返回的 JSON 数组中第一个元素的 venueID 属性值为 1 7. perform....andExpect里的is3xxRedirection() 去官网查到：判断是不是在org.springframework.http.HttpStatus.Series.REDIRECTION里，也就是3开头的意思是重定向 （1开头：info，2开头：成功，3开头：重定向，4开头：客户那边的错误，5开头：服务器的错误） 感谢阅读！新人第一篇文章，请指正！","categories":[],"tags":[{"name":"Mockito","slug":"Mockito","permalink":"http://jyideng.github.io/tags/Mockito/"},{"name":"Java","slug":"Java","permalink":"http://jyideng.github.io/tags/Java/"}]}],"categories":[],"tags":[{"name":"ollama","slug":"ollama","permalink":"http://jyideng.github.io/tags/ollama/"},{"name":"Deepseek","slug":"Deepseek","permalink":"http://jyideng.github.io/tags/Deepseek/"},{"name":"nlp","slug":"nlp","permalink":"http://jyideng.github.io/tags/nlp/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://jyideng.github.io/tags/ubuntu/"},{"name":"clang++","slug":"clang","permalink":"http://jyideng.github.io/tags/clang/"},{"name":"Vuex","slug":"Vuex","permalink":"http://jyideng.github.io/tags/Vuex/"},{"name":"Mockito","slug":"Mockito","permalink":"http://jyideng.github.io/tags/Mockito/"},{"name":"Java","slug":"Java","permalink":"http://jyideng.github.io/tags/Java/"}]}